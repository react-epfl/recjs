#include <node.h>
#include <v8.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

using namespace v8;
using namespace node;

static void init(Handle<Object> target);
Handle<Value> buildAsync(const Arguments& args);
static void calcMatrix(uv_work_t *req);
static void calcMatrixAfter(uv_work_t *req);

// contains all the data for async thread
struct simple_request {
  int x;
  int y;
  Persistent<Function> cb;
  int result;
  // maybe it matters to put the char[] last?  not sure.
  //char name[20];
};

/**
 * Calculate Matrix in thread
 *
 * this function happens on the thread pool
 * doing v8 things in here will make bad happen.
 */
static void calcMatrix(uv_work_t* req) {
  struct simple_request * sr = (struct simple_request *)req->data;
  sleep(2); // just to make it less pointless to be async.
  sr->result = sr->x + sr->y;
}

/**
 * Callback from Calculate Matrix
 *
 */
static void calcMatrixAfter(uv_work_t* req) {
  HandleScope scope;

  struct simple_request * sr = (struct simple_request *)req->data;
  delete req;
  //Local<Value> argv[3];
  //argv[0] = Local<Value>::New(Null());
  //argv[1] = Integer::New(req->result);
  //argv[2] = String::New(sr->name);
  TryCatch try_catch;
  const unsigned argc = 1;
  Local<Value> argv[argc] = { Local<Value>::New(Integer::New(sr->result))};
  sr->cb->Call(Context::GetCurrent()->Global(), argc, argv);

  if (try_catch.HasCaught()) {
    FatalException(try_catch);
  }
  sr->cb.Dispose();
  free(sr);
  return;
}

/**
 * Builds a recommendation matrix from arguments and saves it in c++
 */

Handle<Value> buildMatrixAsync(const Arguments& args) {
  HandleScope scope;

  if (args.Length() != 2 || !args[1]->IsFunction()) {
    const char *usage = "usage: object+callback";
    return ThrowException(Exception::Error(String::New(usage)));
  }

  // give data to the callback
  Local<Function> cb = Local<Function>::Cast(args[1]);

  simple_request *sr = new simple_request;
  //sr->name = "Evgeny test";
  sr->cb = Persistent<Function>::New(cb);
  sr->x = 5;
  sr->y = 2;

  // do calculations
  uv_work_t* work_ref = new uv_work_t();
  work_ref->data = sr;

  uv_queue_work(uv_default_loop(), work_ref, calcMatrix, calcMatrixAfter);

  return Undefined();
}

/**
 * Calculate response based on query in thread
 *
 * this function happens on the thread pool
 * doing v8 things in here will make bad happen.
 */
static void calcQueryResponse(uv_work_t* req) {
  struct simple_request * sr = (struct simple_request *)req->data;
  sleep(2); // just to make it less pointless to be async.
  sr->result = sr->x + sr->y;
}

/**
 * Callback from Calculate Query
 *
 */
static void calcQueryResponseAfter(uv_work_t* req) {
  HandleScope scope;

  struct simple_request * sr = (struct simple_request *)req->data;
  delete req;
  //Local<Value> argv[3];
  //argv[0] = Local<Value>::New(Null());
  //argv[1] = Integer::New(req->result);
  //argv[2] = String::New(sr->name);
  TryCatch try_catch;
  const unsigned argc = 1;
  Local<Value> argv[argc] = { Local<Value>::New(Integer::New(sr->result))};
  sr->cb->Call(Context::GetCurrent()->Global(), argc, argv);

  if (try_catch.HasCaught()) {
    FatalException(try_catch);
  }
  sr->cb.Dispose();
  free(sr);
  return;
}
/**
 * Query a recommendation matrix for objects based on query
 */

Handle<Value> queryAsync(const Arguments& args) {
  HandleScope scope;

  if (args.Length() != 2 || !args[1]->IsFunction()) {
    const char *usage = "usage: object+callback";
    return ThrowException(Exception::Error(String::New(usage)));
  }

  // give data to the callback
  Local<Function> cb = Local<Function>::Cast(args[1]);

  simple_request *sr = new simple_request;
  //sr->name = "Evgeny test";
  sr->cb = Persistent<Function>::New(cb);
  sr->x = 5;
  sr->y = 2;

  // do calculations
  uv_work_t* work_ref = new uv_work_t();
  work_ref->data = sr;

  uv_queue_work(uv_default_loop(), work_ref, calcQueryResponse, calcQueryResponseAfter);

  return Undefined();
}

static void init(Handle<Object> target) {
  HandleScope scope;

  NODE_SET_METHOD(target, "buildMatrix", buildMatrixAsync);
  NODE_SET_METHOD(target, "query", queryAsync);
}

// module recoms initialization
NODE_MODULE(recoms, init)

