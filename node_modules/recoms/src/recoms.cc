#include <node.h>
#include <v8.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

using namespace v8;
using namespace node;

static void init(Handle<Object> target);
Handle<Value> buildAsync(const Arguments& args);
static void eio_calc(uv_work_t *req);
static void eio_calc_after(uv_work_t *req);

// contains all the data for async thread
struct simple_request {
  int x;
  int y;
  Persistent<Function> cb;
  int result;
  // maybe it matters to put the char[] last?  not sure.
  //char name[20];
};

// this function happens on the thread pool
// doing v8 things in here will make bad happen.
static void eio_calc(uv_work_t* req) {
  struct simple_request * sr = (struct simple_request *)req->data;
  sleep(2); // just to make it less pointless to be async.
  sr->result = sr->x + sr->y;
}

// called once it's time to execute callback
static void eio_calc_after(uv_work_t* req) {
  HandleScope scope;

  struct simple_request * sr = (struct simple_request *)req->data;
  //Local<Value> argv[3];
  //argv[0] = Local<Value>::New(Null());
  //argv[1] = Integer::New(req->result);
  //argv[2] = String::New(sr->name);
  TryCatch try_catch;
  const unsigned argc = 1;
  Local<Value> argv[argc] = { Local<Value>::New(Integer::New(sr->result))};
  sr->cb->Call(Context::GetCurrent()->Global(), argc, argv);

  if (try_catch.HasCaught()) {
    FatalException(try_catch);
  }
  sr->cb.Dispose();
  free(sr);
  return;
}

Handle<Value> buildAsync(const Arguments& args) {
  HandleScope scope;

  if (args.Length() != 2 || !args[1]->IsFunction()) {
    const char *usage = "usage: object+callback";
    return ThrowException(Exception::Error(String::New(usage)));
  }

  // give data to the callback
  Local<Function> cb = Local<Function>::Cast(args[1]);

  simple_request *sr = new simple_request;
  //sr->name = "Evgeny test";
  sr->cb = Persistent<Function>::New(cb);
  sr->x = 5;
  sr->y = 2;

  // do calculations
  uv_work_t* work_ref = (uv_work_t*) (calloc(1, sizeof(uv_work_t)));
  work_ref->data = sr;

  uv_queue_work(uv_default_loop(), work_ref, eio_calc, eio_calc_after);

  return Undefined();
}

static void init(Handle<Object> target) {
  HandleScope scope;

  NODE_SET_METHOD(target, "build", buildAsync);
}

// module recoms initialization
NODE_MODULE(recoms, init)

